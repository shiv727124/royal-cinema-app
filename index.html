<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Royal Cinema | Pro Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
<script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

<link href="https://fonts.googleapis.com/css2?family=Poppins:wght@300;400;600&display=swap" rel="stylesheet">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">

<style>
/* --- BASE & THEME --- */
:root {
  --gold: #FFD700;
  --gold-glow: rgba(255, 215, 0, 0.5);
  --glass: rgba(30, 30, 35, 0.75);
  --glass-border: rgba(255, 255, 255, 0.08);
  --text: #e0e0e0;
}

body { 
  margin: 0; 
  min-height: 100vh; 
  background: radial-gradient(circle at 50% 0%, #2a2a35, #000); 
  display: flex; 
  justify-content: center; 
  font-family: 'Poppins', sans-serif; 
  color: var(--text); 
  padding: 40px 20px; 
}

::-webkit-scrollbar { width: 8px; height: 8px; }
::-webkit-scrollbar-track { background: #111; }
::-webkit-scrollbar-thumb { background: #333; border-radius: 4px; }
::-webkit-scrollbar-thumb:hover { background: var(--gold); }

/* --- MAIN CONTAINER --- */
.app { 
  width: 100%; 
  max-width: 1100px; 
  background: var(--glass);
  backdrop-filter: blur(16px);
  -webkit-backdrop-filter: blur(16px);
  padding: 50px; 
  border-radius: 30px; 
  box-shadow: 0 20px 80px rgba(0,0,0,0.6); 
  border: 1px solid var(--glass-border); 
  position: relative; 
  overflow: hidden;
  display: flex;
  flex-direction: column;
}

/* Background orb */
.app::before {
  content: ''; position: absolute; top: -150px; left: -150px; width: 400px; height: 400px;
  background: radial-gradient(circle, rgba(255,215,0,0.05), transparent 70%); pointer-events: none;
}

/* --- TYPOGRAPHY --- */
h1 { 
  text-align: center; 
  background: linear-gradient(to bottom, #fff, var(--gold)); -webkit-background-clip: text; color: transparent;
  font-size: 3.5em; margin: 0; letter-spacing: 3px; font-weight: 600; text-transform: uppercase; 
  filter: drop-shadow(0 0 15px var(--gold-glow));
}
.subtitle { text-align: center; color: #888; margin-bottom: 40px; font-size: 0.9em; letter-spacing: 2px; text-transform: uppercase; }

/* --- STATS BAR --- */
.stats-bar { 
  display: flex; justify-content: space-evenly; margin-bottom: 40px; 
  background: rgba(0,0,0,0.3); padding: 20px; border-radius: 20px; border: 1px solid var(--glass-border);
}
.stat { text-align: center; transition: 0.3s; }
.stat:hover { transform: translateY(-5px); }
.stat-val { font-size: 1.8em; font-weight: 600; color: #fff; text-shadow: 0 0 10px rgba(255,255,255,0.2); }
.stat-label { font-size: 0.75em; color: var(--gold); letter-spacing: 1px; text-transform: uppercase; margin-top: 5px; opacity: 0.8; }

/* --- INPUTS --- */
input, select { 
  background: rgba(0,0,0,0.4); color: #fff; border: 1px solid #333; padding: 16px 20px; 
  border-radius: 12px; font-family: 'Poppins', sans-serif; font-size: 14px; transition: all 0.3s ease;
}
input:focus, select:focus { outline: none; border-color: var(--gold); box-shadow: 0 0 20px rgba(255,215,0,0.15); background: rgba(0,0,0,0.6); }

.add-bar { display: flex; gap: 15px; margin-bottom: 30px; position: relative; z-index: 2; }
.add-bar input { flex-grow: 1; font-size: 1.1em; background: rgba(255,255,255,0.03); border: 1px solid rgba(255,255,255,0.1); }

.add-btn { 
  background: linear-gradient(135deg, var(--gold), #ffaa00); color: #000; font-weight: 700; 
  padding: 0 40px; border-radius: 12px; border: none; cursor: pointer; 
  box-shadow: 0 10px 20px rgba(255, 215, 0, 0.2); transition: all 0.3s ease;
  display: flex; align-items: center; gap: 10px;
}
.add-btn:hover { transform: translateY(-3px) scale(1.02); box-shadow: 0 15px 30px rgba(255, 215, 0, 0.4); }
.add-btn:disabled { opacity: 0.6; cursor: not-allowed; filter: grayscale(1); }

.filter-bar { display: grid; grid-template-columns: repeat(5, 1fr); gap: 15px; margin-bottom: 40px; }
.filter-bar select, .filter-bar input { font-size: 0.9em; height: 100%; cursor: pointer; }

/* --- MOVIE CARDS --- */
.list { display: grid; grid-template-columns: 1fr; gap: 20px; }

.movie { 
  position: relative; display: grid; grid-template-columns: 110px 1fr; gap: 25px; 
  background: rgba(255,255,255,0.03); padding: 20px; border-radius: 20px; 
  border: 1px solid rgba(255,255,255,0.05); transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
  overflow: hidden; opacity: 0; animation: fadeIn 0.5s forwards;
}
@keyframes fadeIn { to { opacity: 1; } }
.movie:hover { 
  transform: translateY(-5px) scale(1.01); background: rgba(255,255,255,0.06); 
  box-shadow: 0 15px 40px rgba(0,0,0,0.4); border-color: rgba(255,215,0,0.15);
}

.movie img { 
  width: 110px; border-radius: 12px; aspect-ratio: 2/3; object-fit: cover; 
  box-shadow: 0 5px 15px rgba(0,0,0,0.5); transition: 0.3s;
}
.movie:hover img { box-shadow: 0 8px 25px rgba(255, 215, 0, 0.2); }

.movie-info { display: flex; flex-direction: column; justify-content: center; position: relative; z-index: 2; overflow: hidden; }
.movie-info h3 { margin: 0 0 10px 0; color: #fff; font-size: 1.5em; font-weight: 600; display: flex; align-items: center; gap: 12px; }

.badge { font-size: 0.5em; padding: 4px 10px; border-radius: 20px; font-weight: 600; letter-spacing: 1px; box-shadow: 0 2px 5px rgba(0,0,0,0.3); }
.badge-movie { background: #333; color: #aaa; border: 1px solid #444; }
.badge-tv { background: linear-gradient(45deg, #004e92, #000428); color: #fff; border: 1px solid #004e92; }

.meta { display: flex; gap: 20px; color: #bbb; font-size: 0.9em; margin-bottom: 12px; align-items: center; flex-wrap: wrap; }
.meta span { display: flex; align-items: center; gap: 6px; }
.season-tag { background: rgba(255,215,0,0.1); color: var(--gold); border: 1px solid var(--gold); padding: 2px 8px; border-radius: 6px; font-size: 0.8em; font-weight: 600; }

.movie-info p { color: #888; line-height: 1.6; font-size: 0.95em; margin: 0 0 15px 0; max-width: 90%; }

/* Buttons */
.actions-row { display: flex; flex-wrap: wrap; gap: 10px; align-items: center; margin-top: 5px; }

.trailer-btn { 
  display: inline-flex; align-items: center; gap: 8px; padding: 8px 20px; 
  background: rgba(255,255,255,0.05); color: var(--gold); border: 1px solid rgba(255,215,0,0.3); 
  border-radius: 30px; text-decoration: none; font-size: 0.85em; font-weight: 500; transition: 0.3s; cursor: pointer;
}
.trailer-btn:hover { background: var(--gold); color: #000; box-shadow: 0 0 15px var(--gold-glow); border-color: var(--gold); }

/* Season Pills */
.season-list { display: flex; gap: 8px; overflow-x: auto; padding-bottom: 5px; max-width: 100%; scrollbar-width: none; }
.season-list::-webkit-scrollbar { display: none; }

.season-btn {
  background: rgba(0,0,0,0.5); color: #aaa; border: 1px solid #444; border-radius: 8px;
  padding: 6px 12px; font-size: 0.75em; cursor: pointer; transition: 0.2s; white-space: nowrap; text-decoration: none;
}
.season-btn:hover { background: #333; color: white; border-color: #666; }
.season-btn:active { background: var(--gold); color: black; border-color: var(--gold); }

.delete-btn { 
  position: absolute; top: 20px; right: 20px; width: 40px; height: 40px; border-radius: 50%; 
  background: rgba(0,0,0,0.4); color: #666; border: 1px solid transparent; cursor: pointer; 
  display: flex; align-items: center; justify-content: center; transition: 0.3s; font-size: 1em;
}
.delete-btn:hover { background: rgba(255, 50, 50, 0.15); color: #ff4444; transform: rotate(90deg); border-color: #ff4444; }

.toast { 
  position: fixed; top: 30px; left: 50%; transform: translateX(-50%); background: rgba(20, 20, 20, 0.95); 
  color: #fff; padding: 12px 30px; border-radius: 50px; border: 1px solid var(--gold); 
  box-shadow: 0 10px 40px rgba(0,0,0,0.8); z-index: 1000; display: flex; align-items: center; gap: 12px; 
  font-weight: 500; backdrop-filter: blur(10px); animation: slideDown 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275); 
}
@keyframes slideDown { from { top: -100px; } to { top: 30px; } }

.empty-msg { text-align: center; color: #555; padding: 60px; font-style: italic; letter-spacing: 1px; }
.loading-sentinel { text-align: center; padding: 30px; color: #666; font-size: 0.9em; opacity: 0.7; }

/* Responsive */
@media (max-width: 768px) {
  .filter-bar { grid-template-columns: 1fr 1fr; }
  .movie { grid-template-columns: 1fr; text-align: center; }
  .movie-info h3 { justify-content: center; }
  .meta { justify-content: center; }
  .actions-row { justify-content: center; }
  .delete-btn { top: 10px; right: 10px; }
}
</style>
</head>
<body>
<div id="root"></div>

<script type="text/babel">
const OMDB_API_KEY = "81a98890";
const SUPABASE_URL = "https://dyabpqpaynqncduadbnc.supabase.co"; 
const SUPABASE_KEY = "sb_publishable_TQbpM_1ypruHkx_uGKknOg_k9IFd2B3"; 

const _supabase = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

function App() {
  const [movies, setMovies] = React.useState([]);
  const [loading, setLoading] = React.useState(true);
  const [adding, setAdding] = React.useState(false);
  const [toast, setToast] = React.useState(null);
  
  // Lazy Loading
  const [visibleCount, setVisibleCount] = React.useState(20);
  const loaderRef = React.useRef(null);

  // Inputs
  const [query, setQuery] = React.useState("");
  const [search, setSearch] = React.useState("");
  const [genreFilter, setGenreFilter] = React.useState("All");
  const [yearFilter, setYearFilter] = React.useState("All");
  const [typeFilter, setTypeFilter] = React.useState("All");
  const [sortBy, setSortBy] = React.useState("Date");

  React.useEffect(() => { fetchFromCloud(); }, []);

  // --- LAZY LOAD ---
  React.useEffect(() => {
    const observer = new IntersectionObserver(entries => {
      if (entries[0].isIntersecting) setVisibleCount(prev => prev + 20);
    }, { rootMargin: "100px" });
    if (loaderRef.current) observer.observe(loaderRef.current);
    return () => { if (loaderRef.current) observer.unobserve(loaderRef.current); };
  }, [movies, search, genreFilter, yearFilter, typeFilter]);

  React.useEffect(() => { setVisibleCount(20); }, [search, genreFilter, yearFilter, typeFilter, sortBy]);

  function showToast(msg) {
    setToast(msg);
    setTimeout(() => setToast(null), 3000);
  }

  async function fetchFromCloud() {
    setLoading(true);
    const { data } = await _supabase.from('movies').select('*');
    if (data) setMovies(data);
    setLoading(false);
  }

  async function addMovie() {
    if (!query.trim()) return;
    setAdding(true);

    const res = await fetch(`https://www.omdbapi.com/?t=${encodeURIComponent(query)}&apikey=${OMDB_API_KEY}`);
    const data = await res.json();

    if (data.Response === "True") {
      let seasonInfo = null;
      let type = "movie";

      if (data.Type === "series") {
        type = "series";
        const totalSeasons = data.totalSeasons;
        if (totalSeasons && totalSeasons !== "N/A") {
          try {
            const seasonRes = await fetch(`https://www.omdbapi.com/?i=${data.imdbID}&Season=${totalSeasons}&apikey=${OMDB_API_KEY}`);
            const seasonData = await seasonRes.json();
            if (seasonData.Episodes && seasonData.Episodes.length > 0) {
              const lastEp = seasonData.Episodes[seasonData.Episodes.length - 1];
              seasonInfo = `S${totalSeasons} E${lastEp.Episode}`;
            } else {
              seasonInfo = `S${totalSeasons}`;
            }
          } catch (e) { seasonInfo = `S${totalSeasons}`; }
        }
      }

      const { error } = await _supabase.from('movies').insert([{
        title: data.Title, year: data.Year, poster: data.Poster, imdb_id: data.imdbID,
        rating: data.imdbRating, genre: data.Genre, plot: data.Plot, type: type, season_info: seasonInfo
      }]);

      if (error) {
        if (error.code === '23505') showToast("‚ö†Ô∏è Already in list!");
        else showToast("‚ùå Error saving");
      } else {
        showToast(`‚úÖ Added: ${data.Title}`);
        fetchFromCloud();
        setQuery("");
      }
    } else {
      showToast("‚ùå Not found");
    }
    setAdding(false);
  }

  async function remove(imdb_id) {
    const { error } = await _supabase.from('movies').delete().eq('imdb_id', imdb_id);
    if (!error) {
      setMovies(prev => prev.filter(m => m.imdb_id !== imdb_id));
      showToast("üóëÔ∏è Removed");
    }
  }

  // --- SMART LINK GENERATOR (No API Required) ---
  const getTrailerLink = (title, year, season = null) => {
    let q = `${title} ${year} official trailer`;
    if (season) q = `${title} season ${season} trailer`;
    return `https://www.youtube.com/results?search_query=${encodeURIComponent(q)}`;
  };

  const getSeasonCount = (info) => {
    if (!info) return 0;
    const match = info.match(/S(\d+)/);
    return match ? parseInt(match[1]) : 0;
  };

  // --- FILTERING ---
  const genres = ["All", ...new Set(movies.flatMap(m => m.genre ? m.genre.split(", ") : []))].sort();
  const years = ["All", ...new Set(movies.map(m => m.year))].sort((a, b) => b - a);

  let processed = movies.filter(m => {
    const matchesSearch = m.title.toLowerCase().includes(search.toLowerCase());
    const matchesGenre = genreFilter === "All" || m.genre.includes(genreFilter);
    const matchesYear = yearFilter === "All" || m.year === yearFilter;
    const matchesType = typeFilter === "All" || 
                        (typeFilter === "Movies" && m.type !== "series") || 
                        (typeFilter === "TV Shows" && m.type === "series");
    return matchesSearch && matchesGenre && matchesYear && matchesType;
  });

  processed.sort((a, b) => {
    if (sortBy === "Rating") return parseFloat(b.rating) - parseFloat(a.rating); 
    if (sortBy === "Year") return parseInt(b.year) - parseInt(a.year);
    if (sortBy === "Date") return new Date(b.created_at) - new Date(a.created_at);
    return 0;
  });

  const displayedMovies = processed.slice(0, visibleCount);

  return (
    <div className="app">
      {toast && <div className="toast">{toast}</div>}

      <h1>ROYAL CINEMA</h1>
      <div className="subtitle">ULTIMATE CLOUD WATCHLIST</div>

      <div className="stats-bar">
        <div className="stat">
          <div className="stat-val">{movies.length}</div>
          <div className="stat-label">Total</div>
        </div>
        <div className="stat">
          <div className="stat-val">{movies.filter(m => m.type === 'series').length}</div>
          <div className="stat-label">TV Shows</div>
        </div>
        <div className="stat">
          <div className="stat-val">{genres.length - 1}</div>
          <div className="stat-label">Genres</div>
        </div>
      </div>

      <div className="add-bar">
        <input 
          placeholder="Add Movie or TV Show..." value={query} 
          onChange={e => setQuery(e.target.value)} onKeyDown={e => e.key === "Enter" && addMovie()}
        />
        <button className="add-btn" onClick={addMovie} disabled={adding}>
          {adding ? <i className="fas fa-spinner fa-spin"></i> : <i className="fas fa-plus"></i>} ADD
        </button>
      </div>

      <div className="filter-bar">
        <input placeholder="üîç Search..." value={search} onChange={e => setSearch(e.target.value)} />
        <select value={typeFilter} onChange={e => setTypeFilter(e.target.value)}>
          <option value="All">All Types</option>
          <option value="Movies">Movies Only</option>
          <option value="TV Shows">TV Shows Only</option>
        </select>
        <select value={genreFilter} onChange={e => setGenreFilter(e.target.value)}>
          <option value="All">All Genres</option>
          {genres.map(g => <option key={g} value={g}>{g}</option>)}
        </select>
        <select value={yearFilter} onChange={e => setYearFilter(e.target.value)}>
          <option value="All">All Years</option>
          {years.map(y => <option key={y} value={y}>{y}</option>)}
        </select>
        <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
          <option value="Date">üìÖ Date Added</option>
          <option value="Rating">‚≠ê Highest Rated</option>
          <option value="Year">üÜï Newest Release</option>
        </select>
      </div>

      <div className="list">
        {loading ? <div className="empty-msg">Syncing database...</div> : 
         processed.length === 0 ? <div className="empty-msg">No items found.</div> : 
         <>
           {displayedMovies.map((m) => {
             const seasonCount = m.type === 'series' ? getSeasonCount(m.season_info) : 0;
             return (
              <div className="movie" key={m.imdb_id}>
                <img src={m.poster !== "N/A" ? m.poster : "https://via.placeholder.com/150"} alt="poster" />
                
                <div className="movie-info">
                  <h3>
                    {m.title} 
                    <span className={`badge ${m.type === 'series' ? 'badge-tv' : 'badge-movie'}`}>
                      {m.type === 'series' ? 'TV' : 'MOVIE'}
                    </span>
                  </h3>
                  
                  <div className="meta">
                    <span><i className="fas fa-star" style={{color:'var(--gold)'}}></i> {m.rating}</span>
                    <span><i className="fas fa-calendar"></i> {m.year}</span>
                    <span><i className="fas fa-film"></i> {m.genre}</span>
                    {m.type === 'series' && m.season_info && <span className="season-tag">{m.season_info}</span>}
                  </div>
                  
                  <p>{m.plot}</p>
                  
                  <div className="actions-row">
                    {/* Main Trailer Button */}
                    <a href={getTrailerLink(m.title, m.year)} target="_blank" rel="noopener noreferrer" className="trailer-btn">
                      <i className="fab fa-youtube"></i> Trailer
                    </a>

                    {/* Season Buttons */}
                    {m.type === 'series' && seasonCount > 0 && (
                      <div className="season-list">
                        {Array.from({length: seasonCount}, (_, i) => i + 1).map(s => (
                          <a 
                            key={s} 
                            href={getTrailerLink(m.title, m.year, s)}
                            target="_blank"
                            className="season-btn"
                            title={`Watch Season ${s} Trailer`}
                          >
                            S{s}
                          </a>
                        ))}
                      </div>
                    )}
                  </div>
                </div>
                
                <button className="delete-btn" onClick={() => remove(m.imdb_id)} title="Remove">
                  <i className="fas fa-trash"></i>
                </button>
              </div>
            );
           })}
           {visibleCount < processed.length && <div ref={loaderRef} className="loading-sentinel"><i className="fas fa-circle-notch fa-spin"></i></div>}
         </>
        }
      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById("root")).render(<App />);
</script>
</body>
</html>